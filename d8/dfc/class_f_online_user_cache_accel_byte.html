<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="$langcode">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AccelByte Online Subsystem: FOnlineUserCacheAccelByte Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-logo.css" rel="stylesheet" type="text/css"/>
    <style>
        #top-header-logo {
            height: auto;
        }
        #top-header-logo img {
            height: 40px;
            width: auto;
        }
    </style>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="top-header-logo">
        <img alt="AccelByte Online Subsystem" src="../../AccelByte Main Logo - Horizontal.svg"/>
    </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('d8/dfc/class_f_online_user_cache_accel_byte.html','../../','d0/d23/class_f_online_user_cache_accel_byte-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">FOnlineUserCacheAccelByte Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="../../d7/d3c/_online_user_cache_accel_byte_8h_source.html">OnlineUserCacheAccelByte.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5593b4e8f8bb3c624798baea96917c43" id="r_a5593b4e8f8bb3c624798baea96917c43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5593b4e8f8bb3c624798baea96917c43">QueryUsersByAccelByteIds</a> (int32 LocalUserNum, const TArray&lt; FString &gt; &amp;AccelByteIds, const FOnQueryUsersComplete &amp;Delegate, bool bIsImportant=false)</td></tr>
<tr class="memitem:a3bd71113b3721a68d844ce804ff75c2d" id="r_a3bd71113b3721a68d844ce804ff75c2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bd71113b3721a68d844ce804ff75c2d">QueryUsersByPlatformIds</a> (int32 LocalUserNum, const FString &amp;PlatformType, const TArray&lt; FString &gt; &amp;PlatformIds, const FOnQueryUsersComplete &amp;Delegate, bool bIsImportant=false)</td></tr>
<tr class="memitem:a2e29cec3606130813f5fa2a0b4d4d8a8" id="r_a2e29cec3606130813f5fa2a0b4d4d8a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e29cec3606130813f5fa2a0b4d4d8a8">QueryUsersByAccelByteIds</a> (const FUniqueNetId &amp;UserId, const TArray&lt; FString &gt; &amp;AccelByteIds, const FOnQueryUsersComplete &amp;Delegate, bool bIsImportant=false)</td></tr>
<tr class="memitem:a915c35c637d81aa08ac598ee742e1f2f" id="r_a915c35c637d81aa08ac598ee742e1f2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a915c35c637d81aa08ac598ee742e1f2f">QueryUsersByPlatformIds</a> (const FUniqueNetId &amp;UserId, const FString &amp;PlatformType, const TArray&lt; FString &gt; &amp;PlatformIds, const FOnQueryUsersComplete &amp;Delegate, bool bIsImportant=false)</td></tr>
<tr class="memitem:ae6d0a837ff54e4bd110b9dd633b5115a" id="r_ae6d0a837ff54e4bd110b9dd633b5115a"><td class="memItemLeft" align="right" valign="top">TSharedPtr&lt; const <a class="el" href="../../da/dd5/struct_f_accel_byte_user_info.html">FAccelByteUserInfo</a>, ESPMode::ThreadSafe &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6d0a837ff54e4bd110b9dd633b5115a">GetUser</a> (const FUniqueNetId &amp;UserId)</td></tr>
<tr class="memitem:ac9469219b88424ea4a84dd0baa580832" id="r_ac9469219b88424ea4a84dd0baa580832"><td class="memItemLeft" align="right" valign="top">TSharedPtr&lt; const <a class="el" href="../../da/dd5/struct_f_accel_byte_user_info.html">FAccelByteUserInfo</a>, ESPMode::ThreadSafe &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9469219b88424ea4a84dd0baa580832">GetUser</a> (const <a class="el" href="../../d6/dbd/struct_f_accel_byte_unique_id_composite.html">FAccelByteUniqueIdComposite</a> &amp;UserId)</td></tr>
<tr class="memitem:acab65ce958c9f1e28d9b63b6f2c7d127" id="r_acab65ce958c9f1e28d9b63b6f2c7d127"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acab65ce958c9f1e28d9b63b6f2c7d127">IsStalenessCheckEnabled</a> () const</td></tr>
<tr class="memitem:a0d3ac6e765b3674776f7bc5eb571d17a" id="r_a0d3ac6e765b3674776f7bc5eb571d17a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d3ac6e765b3674776f7bc5eb571d17a">GetTimeUntilStaleSeconds</a> () const</td></tr>
<tr class="memitem:afb14ed71f16795770e0d561c11ef6852" id="r_afb14ed71f16795770e0d561c11ef6852"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb14ed71f16795770e0d561c11ef6852">SetStalenessCheckEnabled</a> (bool bInEnableStalenessChecking)</td></tr>
<tr class="memitem:a70017f76e5d62f92564e7d9dba9082af" id="r_a70017f76e5d62f92564e7d9dba9082af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70017f76e5d62f92564e7d9dba9082af">SetTimeUntilStaleSeconds</a> (double InTimeUntilStaleSeconds)</td></tr>
<tr class="memitem:ad3920cbe70329499948e83e42dc4fad2" id="r_ad3920cbe70329499948e83e42dc4fad2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3920cbe70329499948e83e42dc4fad2">SetUserDataAsStale</a> (const FUniqueNetId &amp;UserUniqueId)</td></tr>
<tr class="memitem:abb2a5482773c5d9262cededa67f942fe" id="r_abb2a5482773c5d9262cededa67f942fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb2a5482773c5d9262cededa67f942fe">SetUserDataAsStale</a> (const FString &amp;InAccelByteId)</td></tr>
<tr class="memitem:a1c3b797c2f5a237fc11d532e38823aaa" id="r_a1c3b797c2f5a237fc11d532e38823aaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c3b797c2f5a237fc11d532e38823aaa">IsUserDataStale</a> (const FUniqueNetId &amp;UserUniqueId)</td></tr>
<tr class="memitem:a79a6134d446e552af7130c7b45429179" id="r_a79a6134d446e552af7130c7b45429179"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79a6134d446e552af7130c7b45429179">IsUserDataStale</a> (const FString &amp;InAccelByteId)</td></tr>
<tr class="memitem:a2f6072073fb0577bd8fa42dedfcfb16f" id="r_a2f6072073fb0577bd8fa42dedfcfb16f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f6072073fb0577bd8fa42dedfcfb16f">Init</a> ()</td></tr>
<tr class="memitem:a3c64bdc3a0122a265a0f2fe964c536ed" id="r_a3c64bdc3a0122a265a0f2fe964c536ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c64bdc3a0122a265a0f2fe964c536ed">AddUsersToCache</a> (const TArray&lt; FAccelByteUserInfoRef &gt; &amp;UsersQueried)</td></tr>
<tr class="memitem:a1052a31b19d3b3dce0449465e6961373" id="r_a1052a31b19d3b3dce0449465e6961373"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1052a31b19d3b3dce0449465e6961373">AddPublicCodeToCache</a> (const FUniqueNetId &amp;UserId, const FString &amp;PublicCode)</td></tr>
<tr class="memitem:ade0e38983edeb236c378c7bfd75b9f34" id="r_ade0e38983edeb236c378c7bfd75b9f34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade0e38983edeb236c378c7bfd75b9f34">AddPublicCodeToCache</a> (const <a class="el" href="../../d6/dbd/struct_f_accel_byte_unique_id_composite.html">FAccelByteUniqueIdComposite</a> &amp;UserId, const FString &amp;PublicCode)</td></tr>
<tr class="memitem:a67f60090e69b111745f64edd5a8975de" id="r_a67f60090e69b111745f64edd5a8975de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67f60090e69b111745f64edd5a8975de">AddLinkedPlatformInfoToCache</a> (const FUniqueNetId &amp;UserId, const TArray&lt; <a class="el" href="../../d1/de6/struct_f_accel_byte_linked_user_info.html">FAccelByteLinkedUserInfo</a> &gt; &amp;LinkedPlatformInfo)</td></tr>
<tr class="memitem:a08efee8465fba7ab2d9f598bad7a425c" id="r_a08efee8465fba7ab2d9f598bad7a425c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08efee8465fba7ab2d9f598bad7a425c">AddLinkedPlatformInfoToCache</a> (const <a class="el" href="../../d6/dbd/struct_f_accel_byte_unique_id_composite.html">FAccelByteUniqueIdComposite</a> &amp;UserId, const TArray&lt; <a class="el" href="../../d1/de6/struct_f_accel_byte_linked_user_info.html">FAccelByteLinkedUserInfo</a> &gt; &amp;LinkedPlatformInfo)</td></tr>
<tr class="memitem:aeee022bd598d74e93eacf3bc42144633" id="r_aeee022bd598d74e93eacf3bc42144633"><td class="memItemLeft" align="right" valign="top">int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeee022bd598d74e93eacf3bc42144633">Purge</a> ()</td></tr>
<tr class="memitem:a3a955336561270b29e20de0268a2cbbd" id="r_a3a955336561270b29e20de0268a2cbbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a955336561270b29e20de0268a2cbbd">IsUserCached</a> (const <a class="el" href="../../d6/dbd/struct_f_accel_byte_unique_id_composite.html">FAccelByteUniqueIdComposite</a> &amp;Id)</td></tr>
<tr class="memitem:a81607432a341ebe38c7f5fda6462ed1e" id="r_a81607432a341ebe38c7f5fda6462ed1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81607432a341ebe38c7f5fda6462ed1e">GetQueryAndCacheArrays</a> (const TArray&lt; FString &gt; &amp;AccelByteIds, TArray&lt; FString &gt; &amp;UsersToQuery, TArray&lt; FAccelByteUserInfoRef &gt; &amp;UsersInCache)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5e0af2f8ad9b0a5a8a005da4e8df6936" id="r_a5e0af2f8ad9b0a5a8a005da4e8df6936"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e0af2f8ad9b0a5a8a005da4e8df6936">GetFromSubsystem</a> (const IOnlineSubsystem *Subsystem, TSharedPtr&lt; <a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html">FOnlineUserCacheAccelByte</a>, ESPMode::ThreadSafe &gt; &amp;OutInterfaceInstance)</td></tr>
<tr class="memitem:a18ae27b7bc217f688d08fe4ee1839564" id="r_a18ae27b7bc217f688d08fe4ee1839564"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18ae27b7bc217f688d08fe4ee1839564">GetFromWorld</a> (const UWorld *World, TSharedPtr&lt; <a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html">FOnlineUserCacheAccelByte</a>, ESPMode::ThreadSafe &gt; &amp;OutInterfaceInstance)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-attribs" class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae293ab1f02f36034a6f65f77eaf2ba4e" id="r_ae293ab1f02f36034a6f65f77eaf2ba4e"><td class="memItemLeft" align="right" valign="top"><a id="ae293ab1f02f36034a6f65f77eaf2ba4e" name="ae293ab1f02f36034a6f65f77eaf2ba4e"></a>
PACKAGE_SCOPE&#160;</td><td class="memItemRight" valign="bottom">: <a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html">FOnlineUserCacheAccelByte</a>(<a class="el" href="../../d5/d5d/class_f_online_subsystem_accel_byte.html">FOnlineSubsystemAccelByte</a>* InSubsystem)</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Manages users that are queried from the AccelByte backend, making bulk calls to retrieve user data, as well as getting extra necessary information for those users, such as platform IDs relevant to the current native platform.</p>
<p>As an explanation of how this works under the hood, the cache is made of shared <a class="el" href="../../da/dd5/struct_f_accel_byte_user_info.html" title="Plain data structure representing an AccelByte user that is cached locally.">FAccelByteUserInfo</a> instances that are put into two maps. One map is for mapping the AccelByte ID to the user's information, and one is for mapping platform information to the user's information. This way either can be queried seamlessly to get the same user data. The only time you won't be able to query a user by their platform IDs is if they are not on the same platform as you, in which you can only query by AccelByte ID.</p>
<p>User data will be kept cached based on how long it has been since they have been accessed. You can configure how long users will stay in cache with the <span class="tt">UserCachePurgeTimeoutSeconds</span> variable in the <span class="tt">OnlineSubsystemAccelByte</span> settings in <span class="tt">DefaultEngine.ini</span>. Users will also not be purged if they were marked as important when queried. </p>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a08efee8465fba7ab2d9f598bad7a425c" name="a08efee8465fba7ab2d9f598bad7a425c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08efee8465fba7ab2d9f598bad7a425c">&#9670;&#160;</a></span>AddLinkedPlatformInfoToCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FOnlineUserCacheAccelByte::AddLinkedPlatformInfoToCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/dbd/struct_f_accel_byte_unique_id_composite.html">FAccelByteUniqueIdComposite</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; <a class="el" href="../../d1/de6/struct_f_accel_byte_linked_user_info.html">FAccelByteLinkedUserInfo</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LinkedPlatformInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds linked platform information to the user cache for a given composite user ID. Creates a new cache entry if the user does not already exist in the cache. </p>

</div>
</div>
<a id="a67f60090e69b111745f64edd5a8975de" name="a67f60090e69b111745f64edd5a8975de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f60090e69b111745f64edd5a8975de">&#9670;&#160;</a></span>AddLinkedPlatformInfoToCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FOnlineUserCacheAccelByte::AddLinkedPlatformInfoToCache </td>
          <td>(</td>
          <td class="paramtype">const FUniqueNetId &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; <a class="el" href="../../d1/de6/struct_f_accel_byte_linked_user_info.html">FAccelByteLinkedUserInfo</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LinkedPlatformInfo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds linked platform information to the user cache for a given user ID. Creates a new cache entry if the user does not already exist in the cache. </p>

</div>
</div>
<a id="ade0e38983edeb236c378c7bfd75b9f34" name="ade0e38983edeb236c378c7bfd75b9f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0e38983edeb236c378c7bfd75b9f34">&#9670;&#160;</a></span>AddPublicCodeToCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FOnlineUserCacheAccelByte::AddPublicCodeToCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/dbd/struct_f_accel_byte_unique_id_composite.html">FAccelByteUniqueIdComposite</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>PublicCode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add PublicCode to a user cache, create new if not exist </p>

</div>
</div>
<a id="a1052a31b19d3b3dce0449465e6961373" name="a1052a31b19d3b3dce0449465e6961373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1052a31b19d3b3dce0449465e6961373">&#9670;&#160;</a></span>AddPublicCodeToCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FOnlineUserCacheAccelByte::AddPublicCodeToCache </td>
          <td>(</td>
          <td class="paramtype">const FUniqueNetId &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>PublicCode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add PublicCode to a user cache, create new if not exist </p>

</div>
</div>
<a id="a3c64bdc3a0122a265a0f2fe964c536ed" name="a3c64bdc3a0122a265a0f2fe964c536ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c64bdc3a0122a265a0f2fe964c536ed">&#9670;&#160;</a></span>AddUsersToCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FOnlineUserCacheAccelByte::AddUsersToCache </td>
          <td>(</td>
          <td class="paramtype">const TArray&lt; FAccelByteUserInfoRef &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>UsersQueried</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an array of freshly queried users to the user cache </p>

</div>
</div>
<a id="a5e0af2f8ad9b0a5a8a005da4e8df6936" name="a5e0af2f8ad9b0a5a8a005da4e8df6936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0af2f8ad9b0a5a8a005da4e8df6936">&#9670;&#160;</a></span>GetFromSubsystem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FOnlineUserCacheAccelByte::GetFromSubsystem </td>
          <td>(</td>
          <td class="paramtype">const IOnlineSubsystem *</td>          <td class="paramname"><span class="paramname"><em>Subsystem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSharedPtr&lt; <a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html">FOnlineUserCacheAccelByte</a>, ESPMode::ThreadSafe &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutInterfaceInstance</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience method to get an instance of this interface from the subsystem passed in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Subsystem</td><td>Subsystem instance that we wish to get this interface from </td></tr>
    <tr><td class="paramname">OutInterfaceInstance</td><td>Instance of the interface that we got from the subsystem, or nullptr if not found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean that is true if we could get an instance of the interface, false otherwise </dd></dl>

</div>
</div>
<a id="a18ae27b7bc217f688d08fe4ee1839564" name="a18ae27b7bc217f688d08fe4ee1839564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ae27b7bc217f688d08fe4ee1839564">&#9670;&#160;</a></span>GetFromWorld()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FOnlineUserCacheAccelByte::GetFromWorld </td>
          <td>(</td>
          <td class="paramtype">const UWorld *</td>          <td class="paramname"><span class="paramname"><em>World</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSharedPtr&lt; <a class="el" href="../../d8/dfc/class_f_online_user_cache_accel_byte.html">FOnlineUserCacheAccelByte</a>, ESPMode::ThreadSafe &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutInterfaceInstance</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience method to get an instance of this interface from the subsystem associated with the world passed in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">World</td><td>World instance that we wish to get the interface from </td></tr>
    <tr><td class="paramname">OutInterfaceInstance</td><td>Instance of the interface that we got from the subsystem, or nullptr if not found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean that is true if we could get an instance of the interface, false otherwise </dd></dl>

</div>
</div>
<a id="a81607432a341ebe38c7f5fda6462ed1e" name="a81607432a341ebe38c7f5fda6462ed1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81607432a341ebe38c7f5fda6462ed1e">&#9670;&#160;</a></span>GetQueryAndCacheArrays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FOnlineUserCacheAccelByte::GetQueryAndCacheArrays </td>
          <td>(</td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>AccelByteIds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; FString &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>UsersToQuery</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; FAccelByteUserInfoRef &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>UsersInCache</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method used by user queries to get an array of users that we still need to query, as well as shared instances to users that we have already queried and can retrieve from the cache </p>

</div>
</div>
<a id="a0d3ac6e765b3674776f7bc5eb571d17a" name="a0d3ac6e765b3674776f7bc5eb571d17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3ac6e765b3674776f7bc5eb571d17a">&#9670;&#160;</a></span>GetTimeUntilStaleSeconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double FOnlineUserCacheAccelByte::GetTimeUntilStaleSeconds </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of time in seconds that it takes for a user's cached data to become stale. </p>

</div>
</div>
<a id="ac9469219b88424ea4a84dd0baa580832" name="ac9469219b88424ea4a84dd0baa580832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9469219b88424ea4a84dd0baa580832">&#9670;&#160;</a></span>GetUser() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSharedPtr&lt; const <a class="el" href="../../da/dd5/struct_f_accel_byte_user_info.html">FAccelByteUserInfo</a>, ESPMode::ThreadSafe &gt; FOnlineUserCacheAccelByte::GetUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/dbd/struct_f_accel_byte_unique_id_composite.html">FAccelByteUniqueIdComposite</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempt to get a user from the cache by a composite ID structure. </p>

</div>
</div>
<a id="ae6d0a837ff54e4bd110b9dd633b5115a" name="ae6d0a837ff54e4bd110b9dd633b5115a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d0a837ff54e4bd110b9dd633b5115a">&#9670;&#160;</a></span>GetUser() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSharedPtr&lt; const <a class="el" href="../../da/dd5/struct_f_accel_byte_user_info.html">FAccelByteUserInfo</a>, ESPMode::ThreadSafe &gt; FOnlineUserCacheAccelByte::GetUser </td>
          <td>(</td>
          <td class="paramtype">const FUniqueNetId &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempt to get a user from the cache by an AccelByte unique ID. This ID comes from either an <a class="el" href="../../da/dd5/struct_f_accel_byte_user_info.html#a9f35ed0fc405d0a9a5f32feee5915641" title="Composite ID representation for this user, platform information may be blank if we cannot retrieve th...">FAccelByteUserInfo::Id</a> field, or from the result of a query users call. </p>

</div>
</div>
<a id="a2f6072073fb0577bd8fa42dedfcfb16f" name="a2f6072073fb0577bd8fa42dedfcfb16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6072073fb0577bd8fa42dedfcfb16f">&#9670;&#160;</a></span>Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FOnlineUserCacheAccelByte::Init </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the user cache. This will load configuration values from the engine INI for the cache. Called from the subsystem initialization method. </p>

</div>
</div>
<a id="acab65ce958c9f1e28d9b63b6f2c7d127" name="acab65ce958c9f1e28d9b63b6f2c7d127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab65ce958c9f1e28d9b63b6f2c7d127">&#9670;&#160;</a></span>IsStalenessCheckEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FOnlineUserCacheAccelByte::IsStalenessCheckEnabled </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if staleness checks for cached user data is enabled. </p>

</div>
</div>
<a id="a3a955336561270b29e20de0268a2cbbd" name="a3a955336561270b29e20de0268a2cbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a955336561270b29e20de0268a2cbbd">&#9670;&#160;</a></span>IsUserCached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FOnlineUserCacheAccelByte::IsUserCached </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/dbd/struct_f_accel_byte_unique_id_composite.html">FAccelByteUniqueIdComposite</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether a user exists already in the cache so that we don't requery them. </p>

</div>
</div>
<a id="a79a6134d446e552af7130c7b45429179" name="a79a6134d446e552af7130c7b45429179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a6134d446e552af7130c7b45429179">&#9670;&#160;</a></span>IsUserDataStale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FOnlineUserCacheAccelByte::IsUserDataStale </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>InAccelByteId</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether user's cached data has become stale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InAccelByteId</td><td>String representation of the user ID that you wish to check the staleness </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data stale, false otherwise </dd></dl>

</div>
</div>
<a id="a1c3b797c2f5a237fc11d532e38823aaa" name="a1c3b797c2f5a237fc11d532e38823aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3b797c2f5a237fc11d532e38823aaa">&#9670;&#160;</a></span>IsUserDataStale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FOnlineUserCacheAccelByte::IsUserDataStale </td>
          <td>(</td>
          <td class="paramtype">const FUniqueNetId &amp;</td>          <td class="paramname"><span class="paramname"><em>UserUniqueId</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether user's cached data has become stale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserUniqueId</td><td>Unique ID of the user that we wish to check the staleness, must be an AccelByte unique ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data stale, false otherwise </dd></dl>

</div>
</div>
<a id="aeee022bd598d74e93eacf3bc42144633" name="aeee022bd598d74e93eacf3bc42144633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee022bd598d74e93eacf3bc42144633">&#9670;&#160;</a></span>Purge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32 FOnlineUserCacheAccelByte::Purge </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches through the user caches for a user that hasn't been accessed in longer than the maximum time set for this cache. If a user is found that exceeds this max time, and they are not marked as important, they will be removed from the cache entirely.</p>
<p>Will return the number of users purged from the cache.</p>
<p>Do not call this method directly, it will be called from the owning OnlineSubsystem's ticker! </p>

</div>
</div>
<a id="a2e29cec3606130813f5fa2a0b4d4d8a8" name="a2e29cec3606130813f5fa2a0b4d4d8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e29cec3606130813f5fa2a0b4d4d8a8">&#9670;&#160;</a></span>QueryUsersByAccelByteIds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FOnlineUserCacheAccelByte::QueryUsersByAccelByteIds </td>
          <td>(</td>
          <td class="paramtype">const FUniqueNetId &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>AccelByteIds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FOnQueryUsersComplete &amp;</td>          <td class="paramname"><span class="paramname"><em>Delegate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bIsImportant</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries all of the IDs listed in the array on the AccelByte backend for user information, including platform IDs. If platform IDs are found and match the current platform that we are on, extra queries will be made through the platform OSSes.</p>
<p>Caches any results that we get from the backend, as well as will not query from the backend again if a duplicate is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td>FUniqueNetId of the user that is attempting to query for users </td></tr>
    <tr><td class="paramname">AccelByteIds</td><td>Array of strings that represent an ID for a single user </td></tr>
    <tr><td class="paramname">Delegate</td><td>Delegate fired when the query is complete </td></tr>
    <tr><td class="paramname">bIsImportant</td><td>Whether or not we want to mark these users as important so that they stay in the cache, defaults to false. This should only be used for users that we want to persist for the length of the game session, such as friends. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5593b4e8f8bb3c624798baea96917c43" name="a5593b4e8f8bb3c624798baea96917c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5593b4e8f8bb3c624798baea96917c43">&#9670;&#160;</a></span>QueryUsersByAccelByteIds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FOnlineUserCacheAccelByte::QueryUsersByAccelByteIds </td>
          <td>(</td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>LocalUserNum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>AccelByteIds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FOnQueryUsersComplete &amp;</td>          <td class="paramname"><span class="paramname"><em>Delegate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bIsImportant</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries all of the IDs listed in the array on the AccelByte backend for user information, including platform IDs. If platform IDs are found and match the current platform that we are on, extra queries will be made through the platform OSSes.</p>
<p>Caches any results that we get from the backend, as well as will not query from the backend again if a duplicate is found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LocalUserNum</td><td>Index of the user that is attempting to query for other users </td></tr>
    <tr><td class="paramname">AccelByteIds</td><td>Array of strings that represent an ID for a single user </td></tr>
    <tr><td class="paramname">Delegate</td><td>Delegate fired when the query is complete </td></tr>
    <tr><td class="paramname">bIsImportant</td><td>Whether or not we want to mark these users as important so that they stay in the cache, defaults to false. This should only be used for users that we want to persist for the length of the game session, such as friends. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a915c35c637d81aa08ac598ee742e1f2f" name="a915c35c637d81aa08ac598ee742e1f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915c35c637d81aa08ac598ee742e1f2f">&#9670;&#160;</a></span>QueryUsersByPlatformIds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FOnlineUserCacheAccelByte::QueryUsersByPlatformIds </td>
          <td>(</td>
          <td class="paramtype">const FUniqueNetId &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>PlatformType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>PlatformIds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FOnQueryUsersComplete &amp;</td>          <td class="paramname"><span class="paramname"><em>Delegate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bIsImportant</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to query all platform IDs listed for the particular platform specified on the AccelByte backend to find AccelByte user matches. If a matches are found, a subsequent query and cache will be performed to get information from the AccelByte backend on those users.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td>FUniqueNetId of the user that is attempting to query for users </td></tr>
    <tr><td class="paramname">PlatformType</td><td>String representing the type of platform that these IDs belong to </td></tr>
    <tr><td class="paramname">PlatformIds</td><td>Array of strings that represent an ID for a single user </td></tr>
    <tr><td class="paramname">Delegate</td><td>Delegate fired when the query is complete </td></tr>
    <tr><td class="paramname">bIsImportant</td><td>Whether or not we want to mark these users as important so that they stay in the cache, defaults to false. This should only be used for users that we want to persist for the length of the game session, such as friends. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bd71113b3721a68d844ce804ff75c2d" name="a3bd71113b3721a68d844ce804ff75c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd71113b3721a68d844ce804ff75c2d">&#9670;&#160;</a></span>QueryUsersByPlatformIds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FOnlineUserCacheAccelByte::QueryUsersByPlatformIds </td>
          <td>(</td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>LocalUserNum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>PlatformType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>PlatformIds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FOnQueryUsersComplete &amp;</td>          <td class="paramname"><span class="paramname"><em>Delegate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bIsImportant</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to query all platform IDs listed for the particular platform specified on the AccelByte backend to find AccelByte user matches. If a matches are found, a subsequent query and cache will be performed to get information from the AccelByte backend on those users.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LocalUserNum</td><td>Index of the user that is attempting to query for other users </td></tr>
    <tr><td class="paramname">PlatformType</td><td>String representing the type of platform that these IDs belong to </td></tr>
    <tr><td class="paramname">PlatformIds</td><td>Array of strings that represent an ID for a single user </td></tr>
    <tr><td class="paramname">Delegate</td><td>Delegate fired when the query is complete </td></tr>
    <tr><td class="paramname">bIsImportant</td><td>Whether or not we want to mark these users as important so that they stay in the cache, defaults to false. This should only be used for users that we want to persist for the length of the game session, such as friends. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb14ed71f16795770e0d561c11ef6852" name="afb14ed71f16795770e0d561c11ef6852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb14ed71f16795770e0d561c11ef6852">&#9670;&#160;</a></span>SetStalenessCheckEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FOnlineUserCacheAccelByte::SetStalenessCheckEnabled </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bInEnableStalenessChecking</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable staleness checks in the user cache. Intended for runtime testing of cache. Prefer using ini or command line to enable or disable staleness checks. </p>

</div>
</div>
<a id="a70017f76e5d62f92564e7d9dba9082af" name="a70017f76e5d62f92564e7d9dba9082af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70017f76e5d62f92564e7d9dba9082af">&#9670;&#160;</a></span>SetTimeUntilStaleSeconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FOnlineUserCacheAccelByte::SetTimeUntilStaleSeconds </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>InTimeUntilStaleSeconds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the amount of time in seconds that it takes for a user's cached data to become stale. Intended for runtime testing of cache. Prefer using ini or command line to control staleness time. </p>

</div>
</div>
<a id="abb2a5482773c5d9262cededa67f942fe" name="abb2a5482773c5d9262cededa67f942fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2a5482773c5d9262cededa67f942fe">&#9670;&#160;</a></span>SetUserDataAsStale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FOnlineUserCacheAccelByte::SetUserDataAsStale </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>InAccelByteId</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempts to mark the referenced user's cached data as stale. If found, the force stale flag on the user's data will be updated, and the next request to get user data will request new data for this user, regardless of whether the stale datetime has been reached. This flag will be reset after the request is processed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InAccelByteId</td><td>String representation of the user ID that you wish to mark stale </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if flag was set, false otherwise </dd></dl>

</div>
</div>
<a id="ad3920cbe70329499948e83e42dc4fad2" name="ad3920cbe70329499948e83e42dc4fad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3920cbe70329499948e83e42dc4fad2">&#9670;&#160;</a></span>SetUserDataAsStale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FOnlineUserCacheAccelByte::SetUserDataAsStale </td>
          <td>(</td>
          <td class="paramtype">const FUniqueNetId &amp;</td>          <td class="paramname"><span class="paramname"><em>UserUniqueId</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempts to mark the referenced user's cached data as stale. If found, the force stale flag on the user's data will be updated, and the next request to get user data will request new data for this user, regardless of whether the stale datetime has been reached. This flag will be reset after the request is processed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserUniqueId</td><td>Unique ID of the user that we wish to set as stale, must be an AccelByte unique ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if flag was set, false otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.9.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
</div>
</body>
</html>
